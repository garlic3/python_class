day09. 이진트리


트리
	계층적인 자료를 나타내는 자료구조
	* 데이터사이의 계층관계

	컴퓨터 운영체제의 파일 시스템
	회사 조직이나 기관의 계층구조


재귀호출
	함수 내부에서 함수가 자기자신을 또다시 호출하는 행위

이진트리(binary tree)
	모든 노드의 자식이 최대 두개를 갖는 자료구조(오른쪽, 왼쪽)
	
이진검색트리(Binary Search Tree)
	이진 탐색트리. 왼쪽노드와 그 이하의 노드는 루트보다 값이 작고 오른쪽 노드와 그 이하의 노드는 루트보다 값이 큰 트리
	시간복잡도 O(log n)
	

	1. 구조가 단순
	2. 검색 속도가 빠름
	3. 노드를 삽입하기가 편리

용어

	루트 : 가장 위쪽에 있는 노드
	엣지: 각 노드들이 연결된 선(branch, link 라고도 부름)
	차수: 각 노드가 갖는 자식의 수
	단말노드: 외부노드. 자식이 없는 차수가 0인 노드. 리프라고 부르기도함
	비단말 노드: 내부노드. 루프를 제외한 노드

	레벨 :루트에서 떨어져 있는 정도. 루트의 레벨 = 0, 한단계씩 내려갈때마다 레벨이 1씩 증가
	자식: 어떤 두 노드가 연결 되었을때 아래쪽 노드
	부모: 어떤 두 노드가 연결 되었을때 위쪽 노드( 루트는 부모를 갖지 않음)
	형제: 같은 부모를 가지는 노드
	조상: 어떤 노드의 위쪽에 있는 모든 노드들
	자손: 어떤 노드의 아래쪽에 있는 모든 노드들
	높이: 루트에서 가장 멀리있는 리프 노드까지의 거리(빈 트리는 높이가 0)
	서브트리: 어떤 노드를 루트로 하고 그 자손으로 구성된 트리
	키: 탐색에 사용되는 노드에 저장된 정보


	[0]
[1]		[2]

*1과 2의 순서를 구별하지 않으면 무순서 트리
*순서를 구별하면 순서트리

무순서트리
	형제 노드의 순서 관계가 없는 트리

순서트리
	형제 노드의 순서 관계가 있는 트리

순서트리 검색
					[0]							level 0
	
			[1]					[2]				level 1
	
	[3]			[4]			[5]			[6]		level 2


	1. 너비 우선 검색(Breadth First Search. BFS)
	수평 검색. 가로 검색. 좌에서 우로 검색하고 한 레벨에서 검색이 끝나면 다음 레벨로 내려감
	0 -> 1 -> 2 -> 3 -> 4 -> 5  -> 6
	*방문한 노드들을 차례로 저장한 후 꺼낼수 있는 자료구조인 큐를 사용(선입선출)

	2. 깊이 우선 검색(Depth First Search. DFS)
	세로 검색. 수직 검색. 리프까지 아래쪽으로 내려가면서 검색하고 리프에 도달하면 다시 부모 노드로 올라간다음 옆으로 넘어감
	순회: 이진트리의 노드 전체를 한번씩 방문하는것을 의미
	스택 또는 재귀로 구현

	(1) 전위순회(preorder)
	root -> left -> right
	0 1 3 4 2 5 6

	(2)중위순회(inorder)
	left -> root -> right
	3 1 4 0 5 2 6

	(3)후위순회(postorder)
	left -> right -> root
	3 4 1 5 6 2 0



균형 검색트리(self-balancing search tree)
	이진 검색트리는 데이터를 오름차순으로 노드를 삽입시 트리의 높이가 선형으로 길어지므로 
	높이를 제한하여 고안된 검색트리

	* 이진검색트리는 데이터의 오름차순으로 노드가 삽입되면 트리의 높이가 깊어지는 단점이 있음
	* 마치 선형 리스트처럼 되어 아주 빠른 검색을 수행할 수가 없어서 높이를 제한하여 고안된 검색트리를 
	* 균형 검색 트리라고함
	[1]
		[2]	
			[3]
				[4]
					[5]

완전 이진트리(complete binary tree)
	마지막 레벨을 제외하고 모든 레벨에 노드가 가득 차 있으며 마지막 노드레벨은 가장 왼쪽에서 오른쪽으로 노드가 채워져 있는 트리

포화 이진트리(full binary tree)
	모든노드가 자식들이 0개 아니면 2개를 가지는 트리

완벽 이진트리(perfect binary tree)
	모든 리프의 레벨이 동일하며 내부노드들은 모두 2개의 자식을 가지는 트리

adt
1. search(x) 이진 검색 트리에서 원소 x를 검색
2. insert(x) 이진 검색 트리에서 원소 x를 삽입
	(1) 빈노드일 경우
	(2) key > root
	(3) key < root
3. remove(x) 이진 검색 트리에서 원소 x를 삭제
	(1) 자식노드가 없는 경우
		* 삭제할 노드가 부모노드의 왼쪽이면 부모의 왼쪽 포인터를 None으로
		* 삭제할 노드가 부모노드의 오른쪽이면 부모의 오른쪽 포인터를 None으로
	(2) 자식노드가 1개 
		* 삭제할 노드가 부모노드의 왼쪽이면 부모의 왼쪽 포인터를 삭제할 노드의 자식으로
		* 삭제할 노드가 부모노드의 오른쪽이면 부모의 오른쪽 포인터를 삭제할 노드의 자식으로
	(3) 자식노드가 2개 
		* 삭제할 노드의 왼쪽 서브트리에서 키값이 가장 큰 노드를 검색
		* 검색한 노드를 삭제 위치로 옮김. 검색한 노드의 데이터를 삭제할 노드위치에 복사
		* 옮긴 노드를 삭제. ( 옮긴 노드에 자식이 없으면 (1)으로 삭제 있으면 (2)로 삭제
		
		이전이나 이후의 값으로 대체
		왼쪽 서브트리에서 제일 오른쪽 값 = 가장 큰값
		오른쪽 서브트리에서 제일 왼쪽 값 = 가장 작은값

4. isEmpty() 이검색 트리에 키가 하나도 없이 비어 있는가?
5. clear() 이진 검색 트리를 깨끗히 비운다

배열을 이진트리로
	필요한 값: 배열, 시작인덱스, 끝인덱스
	한번 이동할때마다 소요되는 시간이 반이 줄어듬


========================================


복습
day05 스택, 큐 

추상 자료형, 추상 데이터 타입(Abstract Data Type, ADT)
	자료와 자료에 대한 연산들만 추상적으로 정의한것
	Characters: 자료의 속성(구성 요소)
	Operations: 자료의 연산(로직)
	추상 자료형을 구체적으로 구현한 것을 자료구조라고 함

* 데이터와 연산만 만족하면 구현은 정해진 방법이 없음
* 사용자는 사용은 할 수 있지만 내부적으로 어떻게 구현되는지는 알수 없음
* 내부의 데이터를 보호하고 내부적으로 코드가 변경되더라도 여전히 사용할 수 있음
* 사용 설명서


알고리즘
	문제를 해결하는 절차 또는 순서

자료구조
	데이터를 효율적으로 관리 할 수 있게 조직화시켜 저장하는 방법

	단순 구조: 문자열, 실수, 정수 등
	
	복합 자료구조
	1. 선형 자료구조: 자료가 순차적으로 나열된 형태
		리스트(배열 기반. 연속 방식)
		연결리스트(포인터 기반. 연결 방식)
		스택
		큐
		덱
		
	2.비선형 자료구조: 자료가 순차적이지 않고 복잡한 연결 관계를 갖는 형태. 트리, 그래프 등

스택(Stack)
	가장 마지막에 넣은 데이터를 가장 먼저 꺼내는 구조
	후입선출(LIFO, Last In First Out)
	실행취소(Ctrl + z, undo)
	웹 브라우저 방문기록(뒤로가기)
	재귀적 알고리즘( 재귀함수: 자기 자신을 다시 호출하는 함수)

	필요 연산
		1. create(size): 스택을 생성 (초기화)
		2. is_empty() 스택이 비어있다면 true, 아니라면 false
		3 is_full() 스택이 다 찼다면 true, 아니라면 false
		4. push(item): 만약 size을 초과한다면 false
		5. pop() :top에 위치한 item을 반환하면서 제거
		6. peek(): top에 위치한 item을 반환

		top: 스택의 윗부분(푸시하고 팝하는 부분)
		bottom: 아랫부분(인덱스가 0인 원소)
		capacity: 스택의 크기 
		
		스택 포인터: 스택에 쌓여 있는 데이터의 개수
		
		스택에서의 예외처리
		1. 빈 스택 에서 데이터를 꺼내려고 할때
		2. 가득찬 스택에 데이터를 넣으려고 할 때

* 초기화(배열의 크기)
* 데이터 개수
* is_empty() 스택이 비어있는지 판단
* is_full() 스택이 가득 차 있는지 판단
* 데이터 푸시
* 데이터 픽
* 데이터 팝
* 모든 데이터 삭제
* 데이터 검색(꼭대기 -> 바닥 선형검색)
* 모든 데이터를 출력(바닥 -> 꼭대기) 

	* 괄호열 문제
	* 회문 문제


큐(Queue)
	가장 먼저 넣은 데이터를 가장 먼저 꺼내는 구조
	선입선출(FIFO, First In First Out)
	프린터의 출력 처리(스풀링)
	프로세스 관리 
	
	필요 연산
		1. create(size) : 큐를 생성(초기화)
		2. is_empty() 비어있다면 true, 아니라면 false
		3. is_full() 다 찼다면 true, 아니라면 false
		4. enqueue:() 큐에 데이터를 추가
		5. dequeue(): 큐에서 데이터를 꺼내기
		6. peek(): 맨 처음 데이터를 삭제하지 않고 반환(디큐에서 꺼낼 데이터)

		front: 데이터를 꺼내는 쪽(맨앞)
		rear: 데이터를 넣는 쪽(맨뒤)


	파이썬 큐 라이브러리
		https://docs.python.org/ko/3/library/queue.html
		import queue
		Queue: 일반적인 큐 구조
		LifoQueue : 스택처럼 후입선출 되는 큐 구조
		PriorityQueue: 데이터에 우선순위를 넣어 우선순위가 높은순으로 출력
		
		qsize()
			큐의 사이즈
		empty()
			비어있으면 True, 아니면 False
		full()
			가득차있으면 True, 아니면 False
		put()
			데이터 넣기
		get()
			항목을 제거하고 반환


	링 버퍼(Ring Buffer)
		요소를 앞쪽으로 이동시키지 않는 큐
		맨끝과 맨앞이 연결되는 자료구조

		식별하기 위한 변수 

		front: 첫번째 요소의 인덱스(디큐 할 위치)
		rear: 마지막 요소 하나 뒤의 인덱스(인큐 될 위치)
		
	
	매직메소드
	__ -> 더블 언더스코어 = 던더 
	매직메소드 또는 던더 메소드라고 함
	이미 파이썬 내부적으로 만들어진 메소드

	__contains()__ 함수
	클래스에 __contains__() 함수를 정의하면 클래스형의 인스턴스에  멤버십 판단 연산자인 in을 적용할 수 있음
	obj.__contains__(x) 를 간단하게 x in obj로 사용 가능

	__len__() 함수
	클래스에 __len__() 함수를 정의하면 클래스형의 인스턴스를 len()함수에 전달할 수 있음
	obj.__len__()을 간단하게 len(obj)로 작성할 수 있음

	파이썬 클래스안에서 다른 메소드 부를때는 self.메소드명()

day07 연결리스트

1. 매직메소드
2. 리스트 설명
3. 연결리스트 설명
4. 연결리스트, 리스트의 차이 설명
5. 단순 연결리스트 설명
6. 원형 연결리스트 설명


매직메소드
	__ -> 더블 언더스코어 = 던더 
	매직메소드 또는 던더 메소드라고 함
	이미 파이썬 내부적으로 만들어진 메소드

	__contains()__ 함수
	클래스에 __contains__() 함수를 정의하면 클래스형의 인스턴스에  멤버십 판단 연산자인 in을 적용할 수 있음
	obj.__contains__(x) 를 간단하게 x in obj로 사용 가능

	__len__() 함수
	클래스에 __len__() 함수를 정의하면 클래스형의 인스턴스를 len()함수에 전달할 수 있음
	obj.__len__()을 간단하게 len(obj)로 작성할 수 있음

	파이썬 클래스안에서 다른 메소드 부를때는 self.메소드명()

is : 변수의 Object(객체)가 같을 때 True
== : 변수의 values(값)이 같을 때 True
== 


프라이빗 필드 또는 프라이빗 메소드
	변수나 메소드명 앞에 __ (더블언더바)를 붙임
	객체 내부에서만 사용(클래스 내부에서만 접근 가능. 외부에서 접근 불가)

리스트(배열기반. 연속방식) 
	저장 공간의 연속성이 있음. 인덱스를 사용하여 바로 접근할수 있음
	요소 하나당 필요한 공간이 작음
	총 데이터의 개수를 모를 경우, 수용할 수 있는 충분한 크기를 만들어야 하므로 데이터 개수가 적을 경우 공간의 낭비가 발생
	데이터의 개수가 만들어둔 리스트의 크기보다 클 경우 더 큰 크기의 배열로 값을 옮겨야 함

	ADT
	1. i번째 자리에 데이터 삽입
	2. 마지막 자리에 데이터 삽입
	3. i번째 자리 데이터 삭제
	4. 데이터 x 삭제
	5. 데이터 x의 인덱스 반환
	6. 데이터 x의 개수 반환

	구현
	1. insert(i,data)
	2. append(data)
	3. pop(i)
	4. remove(data)
	5. index(data)
	6. count(data)

	
연결리스트(포인터기반. 연결방식)
	저장 공간의 연속성이 없음. 
	요소 하나당 데이터와 참조값을 가지기 때문에 필요한 공간이 리스트보다 큼
	공간의 연속성이 없기떄문에 바로 값에 접근하기 어려움(순차적으로 찾아가야함)

	노드: 기초적인 단위. 하나의 요소
	데이터(값)과 다음 노드를 참조하는 주소값을 가지고 있음
	
	[데이터]	[데이터]	[데이터]
	[주소값]	[주소값]	[주소값]

	머리노드(head node) : 첫번째 노드
	꼬리노드(tail node) : 마지막 노드

	ADT
	1. i번째 자리에 데이터 삽입
	2. 마지막 자리에 데이터 삽입
	3. i번째 자리 데이터 삭제
	4. 데이터 x 삭제
	5. 데이터 x의 인덱스 반환
	6. 데이터 x의 개수 반환
	7. 데이터의 총개수 
	8. 비어있는지 확인
	9. 모든 데이터 삭제
	10. 모든 데이터 출력
	
	
	Node 클래스
	1. data 데이터
	2. next 다음 노드의 주소값

	LinkedList 클래스
	1. head 머리노드
	2. node_num 노드의 개수 
	3. 연산

원형 이중 연결리스트

	원형 연결 리스트
	1. 꼬리노드와 머리노드를 참조하는 구조
	머리노드와 꼬리노드를 쉽게 찾을수 있기 때문에 금방 찾을수 있음

	이중 연결 리스트(양뱡항 리스트)
	2. 각 노드를 데이터, 앞쪽 노드에 대한 주소값, 뒤쪽노드에 대한 주소값으로 구성
	단점. 메모리를 더 사용하게 됨

	단순 연결 리스트에서는 꼬리 노드에 접근하려면 추가적인 시간이 발생
	



