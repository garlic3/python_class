
데이터 과학자가 하는 가장 기초적인 중요한 일 = 데이터를 수집하고 분석이 가능한 형태로 정리하는 것

판다스
1. 판다스 정의 (관련사이트, 형식)

2. 시리즈
	1차원 배열

	pd.Series(딕셔너리 또는 리스트)
	* 딕셔너리의 경우 키값이 인덱스 라벨로 지정됨
	
	- 시리즈 -> 리스트
		dict(시리즈명)			
	- 시리즈 -> 딕셔너리
		list(시리즈명)
	- 시리즈명
		시리즈명.name = 이름
		시리즈 자체에 이름을 부여
	- 인덱스
		정수형 위치 인덱스, 인덱스라벨
		위치 인덱스는 부여하지 않아도 자동으로 지정됨
		시리즈명.rename({'기존이름':'새로운이름'}, inplace=True)
		* inplace 옵션을 True로 주지 않으면 원본에 영향을 미치지 않음

	- 시리즈 값 찾기
		시리즈명[위치인덱스 또는 라벨명]
		시리즈명.index = 인덱스값들만 모아서
		시리즈명.values = 값들만 모아서 
		시리즈명.dtype = 데이터의 자료형

	- 시리즈 값 수정
		시리즈명[위치인덱스 또는 라벨명] = 새로운 값

	- 시리즈 값 추가
		시리즈명[새로운 인덱스라벨] = 새로운 값
		* 정수형 위치 인덱스는 에러 발생
	- 시리즈 값 삭제
		del 시리즈명[인덱스라벨명 또는 위치인덱스]
		pop()	원본에서 삭제
		drop() 제외하고 출력 -> 원본에서 삭제하고 싶으면 inplace=True

	- 슬라이싱
		시리즈명[start:end:step]
		*정수형 위치 인덱스 사용시 end값 포함 x
		* 인덱스 라벨 사용시 end값 포함 o

	- 데이터 자료형
		object 		문자열 또는 복합(여러가지 데이터 타입)
		string		문자열(직접 명시해줘야함)
		int			정수
		float			실수
		bool			참/거짓
		datetime		날짜/시간

		* 데이터 중에 float이랑 int가 섞여있으면 float으로 자동 형변환됨
		astype()
			원하는 자료형으로 변환

3. 데이터프레임
	- 리스트 -> 데이터프레임
		[v1][v2][v3][v4][v5] => 	[v1]
							[v2]	
							[v3]
							[v4]
							[v5]

	- 딕셔너리 -> 데이터프레임

		[k1][v1][v2][v3][v4][v5] => [k1]	
						        [v1]
						        [v2]
						        [v3]
						        [v4]
						        [v5]
	- 데이터프레임-> 리스트
		tolist()
	- 데이터프레임-> 딕셔너리
		to_dict()
		to_dict('list')
		to_dict('index')
		to_dict('records')

	- 데이터프레임 값 찾기
		values	값
		index		인덱스
		columns	컬럼
		dtypes	컬럼의 데이터 타입
		
		info()		데이터 프레임 정보
		head()	상위 5개만
		tail()		하위 5개만

		df.컬럼명
			컬럼 이름이 숫자로 시작하지 않고 공백이나 특수 문자등을 포함하지 않는 조건을 만족해야함
		df.['컬럼명']
			해당 컬럼의 데이터를 불러옴


	loc (label location)
		인덱스 라벨을 기준으로 데이터 읽기
		df.loc[행 인덱스라벨, 열 인덱스라벨]

	iloc (integer location)
		행 번호(정수형 위치 인덱스)를 기준으로 데이터 읽기
		df.iloc[행 인덱스, 열 인덱스] 

	- 인덱스와 컬럼
		df.rename(columns={'이전이름':'새로운이름'})
		df.rename(index={'이전이름':'새로운이름'})
	
	- 데이터프레임 값 수정
		열 전체값 수정
		df[컬럼명] = 새로운값

		행 전체값 수정
		df.loc[인덱스] = 새로운값

		특정값 수정
		df.loc[행, 열] = 새로운값

	- 데이터프레임 값 추가
		df['새로운 행 또는 열 이름'] = 새로운 값

	- 데이터프레임 값 삭제
		행 삭제
		df.drop(행 인덱스)
		
		열 삭제
		df.drop(인덱스 라벨)
		axis 옵션: 행 삭제일 경우 0(기본값), 열 삭제일 경우 1 또는 'columns'
		inplace 옵션: 원본에 삭제 적용시 True

	- 행과 열 변환
		df.transpose()
		df.T
		* 원본에 영향을 미치지 않음
	- 평균
		df.mean()
		numeric_only 옵션: True 일 경우 숫자, 불 값만 있는 열에 대해서만 연산
	- 합계
		df.sum()
	- 정렬
		오름차순 정렬 : df.sort_values(by='기준 컬럼')
		내림차순 정렬 : df.sort_values(by='기준컬럼', ascending=False)

	- 조건식
		비트연산자 사용(&(and), |(or), ~(not))
	- 슬라이싱 ( [start:end:step])
		df.iloc[행 정수형 위치 인덱스, 열 정수형 위치 인덱스]
		df.loc[행 인덱스, 열 컬럼]
		정수형 인덱스는 범위의 끝이 포함되지 않으나 문자열을 사용하면 끝이 포함됨

	- 파일 변환(csv)
		읽기: pd.read_csv('파일명')
		쓰기: pd.to_csv('파일명')
	- 파일 변환(excel)
		읽기: pd.read_excel('파일명')
		만약 에러나면 engine='openpyxl' 옵션 추가
		쓰기: pd.to_excel('파일명')

4. 넘파이
	- 넘파이 개요
		스칼라 : 값이 하나만 있는 데이터
    		벡터 : 하나의 행이 있는 데이터
    		매트릭스 : 행과 열이 있는 데이터

	- 넘파이와 리스트 차이
		리스트: 여러가지 자료형, 데이터 개수가 달라도됨(동적할당)
		넘파이: 원소끼리의 사칙연산 가능, 한가지 데이터타입, 원소의 개수 수정 불가
	
	- 넘파이 찾기

		1차원
		배열명[인덱스번호]

		2차원
		배열명[행][열]

		shape
			(행, 열)
		ndim
			차원
		size
			요소 개수
		dtype
			데이터 타입

	- 넘파이 생성
		np.array(배열)

	- 넘파이 수정
		넘파이명[행][열] = 새로운값

	- 넘파이 추가
		np.insert(배열, index, values, axis='축') :해당 인덱스 번호에 값을 추가
		np.append(배열, values, axis='축') : 마지막 인데스에 값을 추가

	- 넘파이 삭제
		np.delete(배열, 인덱스, axis=None)
			axis 어느축(0이면 행, 1이면 열)

	- zeros(행, 열) : 0으로 이루어진 배열 만들기(기본 자료형 실수)
	   ones(행, 열) : 1로 이루어진 배열 만들기(기본 자료형 실수)
	   arange(start, end, step) : 연속되는 정수로 이루어진 배열 만들기
 	   transpose(): np.transpose(배열명), 배열명.transpose()
	   행과 열을 바꿈(데이터들의 인덱스번호도 행과 열이 바뀌어서 들어가게됨)

	

	- 데이터 자료형				

		자료형							접두사			
		부호가 있는 정수		int				i
		실수 		float						f
		복소수		complex				c
		불		bool						?
		바이트 문자열	string				s
		유니코드		unicode				u
		객체			object				o

	
	- 사칙연산 
		행렬과 다르게 각 자리의 요소끼리 사칙연산

	- 브로드캐스팅
		크기가 다른 배열이 연산이 가능한것
		1. 두 넘파이 배열중 하나가 차원이 1이라면 가능
		2. 두 넘파이 배열의 축의 길이가 동일하면 가능

	- 슬라이싱
		배열명[start:end:step][start:end:step]


5. 데이터 시각화 추가
	- 넘파이 -> 맷플롭
	- 판다스 -> 맷플롭
	- 외부파일(csv) -> 맷플롭

6. 자료구조 및 알고리즘
	- 용어 설명
	- 자료구조(스택, 큐)

day05 스택, 큐 

추상 자료형, 추상 데이터 타입(Abstract Data Type, ADT)
	자료와 자료에 대한 연산들만 추상적으로 정의한것
	Characters: 자료의 속성(구성 요소)
	Operations: 자료의 연산(로직)
	추상 자료형을 구체적으로 구현한 것을 자료구조라고 함

* 데이터와 연산만 만족하면 구현은 정해진 방법이 없음
* 사용자는 사용은 할 수 있지만 내부적으로 어떻게 구현되는지는 알수 없음
* 내부의 데이터를 보호하고 내부적으로 코드가 변경되더라도 여전히 사용할 수 있음
* 사용 설명서


알고리즘
	문제를 해결하는 절차 또는 순서

자료구조
	데이터를 효율적으로 관리 할 수 있게 조직화시켜 저장하는 방법

	단순 구조: 문자열, 실수, 정수 등
	
	복합 자료구조
	1. 선형 자료구조: 자료가 순차적으로 나열된 형태
		리스트(배열 기반. 연속 방식)
		연결리스트(포인터 기반. 연결 방식)
		스택
		큐
		덱
		
	2.비선형 자료구조: 자료가 순차적이지 않고 복잡한 연결 관계를 갖는 형태. 트리, 그래프 등

스택(Stack)
	가장 마지막에 넣은 데이터를 가장 먼저 꺼내는 구조
	후입선출(LIFO, Last In First Out)
	실행취소(Ctrl + z, undo)
	웹 브라우저 방문기록(뒤로가기)
	재귀적 알고리즘( 재귀함수: 자기 자신을 다시 호출하는 함수)

	필요 연산
		1. create(size): 스택을 생성 (초기화)
		2. is_empty() 스택이 비어있다면 true, 아니라면 false
		3 is_full() 스택이 다 찼다면 true, 아니라면 false
		4. push(item): 만약 size을 초과한다면 false
		5. pop() :top에 위치한 item을 반환하면서 제거
		6. peek(): top에 위치한 item을 반환

		top: 스택의 윗부분(푸시하고 팝하는 부분)
		bottom: 아랫부분(인덱스가 0인 원소)
		capacity: 스택의 크기 
		
		스택 포인터: 스택에 쌓여 있는 데이터의 개수
		
		스택에서의 예외처리
		1. 빈 스택 에서 데이터를 꺼내려고 할때
		2. 가득찬 스택에 데이터를 넣으려고 할 때


큐(Queue)
	가장 먼저 넣은 데이터를 가장 먼저 꺼내는 구조
	선입선출(FIFO, First In First Out)
	프린터의 출력 처리(스풀링)
	프로세스 관리 
	
	필요 연산
		1. create(size) : 큐를 생성(초기화)
		2. is_empty() 비어있다면 true, 아니라면 false
		3. is_full() 다 찼다면 true, 아니라면 false
		4. enqueue:() 큐에 데이터를 추가
		5. dequeue(): 큐에서 데이터를 꺼내기
		6. peek(): 맨 처음 데이터를 삭제하지 않고 반환

		front: 데이터를 꺼내는 쪽(맨앞)
		rear: 데이터를 넣는 쪽(맨뒤)

	링 버퍼(Ring Buffer)
		요소를 앞쪽으로 이동시키지 않는 큐


